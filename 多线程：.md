# 多线程：

### 线程定义

详解：https://www.cnblogs.com/riskyer/p/3263032.html

线程分为用户线程和守护线程

用户线程：用来完成程序的业务操作。

守护线程：当jvm中没有用户线程的时候，那么jvm退出。它是特殊的线程，做一些系统性的服务，比如jvm的垃圾回收线程等

在java里每个线程有一个调用栈，即使不在程序中创建了线程，线程也在后台运行着。

java应用总是从main()方法开始执行，main方法运行的线程叫主线程

一个程序往往会调用多个线程，比如调用构造方法会有一个线程，

## 1.线程的创建：

继承Thread类或者实现Runnable接口来定义、实例化和启动线程

```java
//继承Thread类
必须重写run方法，然后在创建线程后，用start方法使线程跑起来
public class MyThread extends Thread{
    String name;
    public MyThread(){}
    public MyThread(String name){
        this.name = name;
    }
    @Override
    public void run(){
        for (int i = 0; i < 300; i++) {
            System.out.println(this.name + " " + i);
        }
    }
    
}


public class Test {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("一号");
        MyThread thread2 = new MyThread("二号");
        thread1.start();
        thread2.start();
    }
}
```

线程有系统给的名字，也可以自己设置

```
getName()
//获取当前运行的线程
Thread.currentThread()

```

当线程的run方法结束了，那么这个线程也结束了。一个线程只能被启动一次

## 2.实现Runnable接口

当一个类实现了这个接口，那么当实例化一个接口后，要把这个接口作为参数传入Thrad的构造方法里

```java
public class Test {
    public static void main(String[] args) {
          //实例化接口
          MyThreadRunnable threadko1 = new MyThreadRunnable("一号");
          MyThreadRunnable threadko2 = new MyThreadRunnable("二号");
          //把接口传入线程
          Thread thread1 = new Thread(threadko1);
          Thread thread2 = new Thread(threadko2);
          //线程开始run
        thread1.start();

        thread2.start();
    }
}
//实现runnable接口
public class MyThreadRunnable implements Runnable{
    @Override
    //重写run方法
    public void run(){
        System.out.println("run方法打印：" + Thread.currentThread().getName() + "run接口实现");
        for (int i = 0; i < 30; i++) {
            System.out.println(this.name + " " + i);
        }
    }
}
```

## 3. 实现Callable接口

```java
//实现接口
public class MyThreadCallable implements Callable<Boolean> {
    String name;
    public MyThreadCallable(){};
    public MyThreadCallable(String name){
        this.name = name;
    }
    @Override
    //重写call方法
    public Boolean call(){
        for (int i = 0; i < 20; i++) {
            System.out.println(this.name);
        }
        return true;
    }
}
//如何使用
public class TestCallThread {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyThreadCallable t1 = new MyThreadCallable("no.1");
        MyThreadCallable t2 = new MyThreadCallable("no.2");


        //开启服务
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        //提交执行
        Future<Boolean> r1 = executorService.submit(t1);
        Future<Boolean> r2 = executorService.submit(t2);

        //获取结果
        boolean rs1 = r1.get();
        boolean rs2 = r2.get();

        //关闭服务
        executorService.shutdown();
        System.out.println(rs1);
        System.out.println(rs2);
    }
}
```

## 线程底部实现原理：静态代理

```java
//总结
1. 真实对象和代理对象都要实现同一个接口
2. 代理对象要代理真实对象
好处
代理对象可以做很多真实对象做不了的事情
真实对象专注做自己的事情
public class 静态代理 {

    public static void main(String[] args) {
        Couple couple = new Couple();
        Company company  = new Company(couple);
        company.HappyMarry();
    }

}
//共同接口
interface Marry{
    void HappyMarry();
}

//真实对象
class Couple implements Marry{
    @Override
    public void HappyMarry(){
        System.out.println("我们那啥了");
    }
}
//代理
class Company implements Marry{
    通过这里来代理真实角色
    Marry target;
    Company(Marry target){
        this.target = target;
    }

    void before(){
        System.out.println("收钱");

    }
    void after(){
        System.out.println("结束");
    }
    @Override
    public void HappyMarry(){
        before();
      this.target.HappyMarry();
        after();
    }
}
```

