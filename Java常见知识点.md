1. java中==比较的是内存地址，equal比较的是内容

2. java中[-128~127]的所有包装对象全部创建好，放到方法区的整数常量池，这个区间的数据不再new，直接从里面取。

3. ==java==数据类型转换：

   ```
   '(byte，short，char)->int->long->float->double'自动会转换的
   char->int时会变成对应的ASCII
   ```

   当高阶转换成低阶则需要强制类型转换，低阶中的相互转换也需要强制转换

   当然double、float等需要相互转换时，就也可以用Double、Float等包装类进行转换。

4. ==final==在使用这个关键字之后

   * 类：不能在被继承，
   * 方法：任何类都不能在修改这个方法
   * 变量：对基本数据类型来说就是不能在改变值，对引用变量来说就是不能在指向其他的对象，及这个引用变量指向的内存地址不能再被改变
   * 当使用这个之后，比如（final String str），在程序中任何str的地方，不再使用引用，直接用str这个对应的值来代替
   * final只有在编译时确定了变量的值才能发挥上述功能，否则（变量a = 一个方法传值过来）就不能发挥功能了。

5. ==hashmap==：

   1. table变量：存储键值对，是一个node数组，node中由hash值，key值，value值。

   table作为数组，每一个元素都是链表的首结点。跟数据结构中处理hash冲突的链地址法差不多，或者就是一样的。

   2. capacity变量：

   3. table是一个数据和链表的复合结构，size记录了key-value对的数量，capacity为HashMap的容量，其容量规则为2的幂次，loadFactor为装载因此，衡量满的程度，而threshold为临界值，当超出临界值时就会扩容。

      hashmap中放入键值，若出现键一致，则会更新值
      
   4. HashMap的数据存储是通过数组+链表/红黑树实现的，存储大概流程是通过hash函数计算在数组中存储的位置，如果该位置已经有值了，判断key是否相同，相同则覆盖，不相同则放到元素对应的链表中，如果链表长度大于8，就转化为红黑树，如果容量不够，则需扩容

   # [HashMap原理(一) 概念和底层架构](https://www.cnblogs.com/LiaHon/p/11142958.html)

6. return this：对象a调用自己的方法a.c(），c方法中以return this结尾，则结束这个方法后，a.c() -》a这个对象了，返回的是a这个引用对象

7. 抽象类是不能直接创建的，只能创建继承它的实体类才能去访问它内部的非抽象方法。

8. 接口：

   * 利用多态的特性使一个接口类型的引用指向这个接口的实现对象

     ```java
     Usb youpan = new Youpan();
     //其中Usb是一个抽象接口，Youpan类实现Usb的方法
     ```

   * 接口中的方法全是抽象的

   * 接口中的属性默认全是public static final